#!/system/bin/sh

# MagiskHide Props Config
# By Didgeridoohan @ XDA Developers

# ====================================================
# ==================== Root check ====================
# ====================================================

# Check for access to the Magisk internals. No access == no root
ls /data/adb>/dev/null 2>&1
if [ "$?" != 0 ]; then
	su -c props "$@" # Rerun script with root access
	exit
fi

# =====================================================
# ================ Paths and variables ================
# =====================================================

COREPATH=CORE_PLACEHOLDER
IMGPATH=$COREPATH/img
MODPATH=$IMGPATH/MagiskHidePropsConf
LATEFILE=LATE_PLACEHOLDER

# Development testing set to false
DEVTESTING=false
case "$1" in
	*t*) # Development testing
		DEVTESTING=true
	;;
esac

# Colours
if [ -f "$LATEFILE" ] && [ "$(cat $LATEFILE | grep "OPTIONCOLOUR=" | sed 's|.*=||' | sed 's|\"||g')" == 0 ] || [ "$LOGNAME" ]; then
	COLOURCHK="nc"
else
	COLOURCHK="$1"
fi
case "$COLOURCHK" in
	*nc*) # Don't use colours
		G=''
		R=''
		Y=''
		B=''
		V=''
		Bl=''
		C=''
		W=''
		N=''
	;;
	*)	# Use colours
		G='\e[01;32m'    # GREEN
		R='\e[01;31m'    # RED
		Y='\e[01;33m'    # YELLOW
		B='\e[01;34m'    # BLUE
		V='\e[01;35m'    # VIOLET
		Bl='\e[01;30m'   # BLACK
		C='\e[01;36m'    # CYAN
		W='\e[01;37m'    # WHITE
		N='\e[00;37;40m' # NEUTRAL
	;;
esac

# ===================================================
# ==================== Functions ====================
# ===================================================

# Load functions
. $MODPATH/util_functions.sh

log_handler "Running props script."

if [ -z "$BBPATH" ]; then
	menu_header "${C}No Busybox found${N}"
	echo ""
	echo "You don't seem to have Busybox installed"
	echo "to your system. Please install it, since"
	echo "it is required to ensure proper"
	echo "functionality of the scripts."
	echo ""
	echo "I recommend osm0sis' Busybox, installable"
	echo "as a Magisk module from the Magisk repo."
	echo ""
	echo "If you do have Busybox installed, please"
	echo "check the module documentation on how to"
	echo "ask for support and provide logs."
	echo ""
	log_handler "No Busybox found."
	log_handler "Exiting... Bye bye.\n\n===================="	
	exit 0
fi

blank_input() {
	# Find menu level
	case $1 in
		1)	INPUT=""
		;;
		2)	INPUT2=""
		;;
		3)	INPUT3=""
		;;
		4)	INPUT4=""
		;;
		5)	INPUT5=""
		;;
	esac

	echo ""
	echo "${R}Don't enter an empty value${N}."
	echo "Try again."
	sleep 2
}

active_option() {
	echo ""
	echo "${R}That's already the active option.${N}"
	sleep 2
}

invalid_input() {
	INPMSG=""

	# Set the message text
	case $1 in
		1)	INPMSG="Only pick from the list above, one at a time."
		;;
		2)	INPMSG="Only enter '${G}y${N}' or '${G}n${N}'."
		;;
		3)	INPMSG="Only enter '${G}y${N}', '${G}n${N}' or '${G}e${N}'."
		;;
		4)	INPMSG="Only enter '${G}y${N}', '${G}n${N}', '${G}r${N}' or '${G}e${N}'."
		;;
		5)	INPMSG="Enter a fingerprint or pick from the options, one at a time."
		;;
	esac

	# Find menu level
	case $2 in
		1)	INPUT=""
		;;
		2)	INPUT2=""
		;;
		3)	INPUT3=""
		;;
		4)	INPUT4=""
		;;
		5)	INPUT5=""
		;;
	esac

	echo ""
	echo "${R}Invalid input${N}. $INPMSG"
	sleep 2
}

reboot_fn() {
	INPUT5=""
	while true
	do
		if [ -z "$INPUT5" ]; then
			if [ "$2" == "reboot" ] || [ "$2" == "reset-script" ]; then
				REBOOTTXT=""
			else
				REBOOTTXT="Reboot - "
			fi
			menu_header "$REBOOTTXT${C}$1${N}"
			echo ""
			if  [ "$2" != "reset-script" ] && [ "$2" != "reboot" ]; then
				echo "Reboot for changes to take effect."
			fi
			echo "Do you want to reboot now (y/n)?"
			echo ""
			if [ "$2" == "p" ] || [ "$2" == "r" ] || [ "$2" == "reset-script" ]; then
				echo -n "Enter ${G}y${N}(es) or ${G}n${N}(o): "
				INV1=2
			else
				echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "	
				INV1=3
			fi
			read -r INPUT5
		fi
		case "$INPUT5" in
			y|Y)
				echo ""
				log_print "Rebooting..."
				setprop sys.powerctl reboot
				sleep 15
				log_handler "Rebooting failed."
				echo ""
				echo "That doesn't seem like it worked..."
				echo "Please reboot manually."
				echo ""
				exit 0
			;;
			n|N)
				if [ "$2" == "p" ] || [ "$2" == "r" ] || [ "$2" == "reset-script" ]; then
					exit_fn
				else
					INPUT=""
					INPUT2=""
					INPUT3=""
					INPUT4=""
					INPUT5=""
					break
				fi
			;;
			e|E)
				if [ "$2" == "p" ] || [ "$2" == "r" ] || [ "$2" == "reset-script" ]; then
					invalid_input $INV1 5
				else
					exit_fn
				fi
			;;
			*)	invalid_input $INV1 5
			;;
		esac
	done
}

exit_fn() {
	menu_header "${C}Bye bye.${N}"
	echo ""
	log_handler "Exiting... Bye bye.\n\n===================="	
	exit 0
}

# ======================== Device's fingerprint ========================
# Second menu level - fingerprint
menu_change_fingerprint() {
	rm -f $CSTMFILE
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			if [ "$(get_file_value $LATEFILE "FINGERPRINTENB=")" == 0 ]; then
				echo "Fingerprint modification currently disabled"
				echo "because of a conflicting module."
				echo ""
				echo "Nothing to do... Returning to main menu."
				sleep 3
				INPUT=""
				break
			else
				if [ "$4" ] && [ "$(get_file_value $LATEFILE "PRINTEDIT=")" == 1 ]; then
					PRINTMODULETXT=" (by this module)"
				else
					PRINTMODULETXT=""
				fi
				if [ "$2" ]; then
					echo "Currently set to${PRINTMODULETXT}:"
					echo ""
					if [ "$PRINTMODULETXT" ]; then
						get_device_used $2
					fi
					echo ${C}$2${N}					
					if [ "$2" != "$3" ]; then
						echo ""
						echo "The original value is:"
						echo ${C}$3${N}
					fi
				else
					echo "ro.build.fingerprint doesn't seem to"
					echo "currently exist on your system."
				fi
				echo ""
				echo "Enter the new fingerprint or"
				echo "pick from the options below."
				echo ""
				echo "${G}f${N} - Pick a certified fingerprint"
				if [ "$PRINTMODULETXT" ]; then
					echo "${G}r${N} - Reset fingerprint"
				fi
				if [ "$(get_file_value $LATEFILE "OPTIONWEB=")" == 0 ]; then
					echo "${G}u${N} - Update fingerprints list (v$(get_file_value $PRINTSLOC "PRINTSV="))"
				fi
				echo "${G}b${N} - Go back."
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter '${G}e${N}' to exit: "
				read -r INPUT2
			fi
		fi
		case "$INPUT2" in
			f|F)	menu_pick_print "$1"
			;;
			r|R)
				if [ "$PRINTMODULETXT" ]; then
					menu_reset_print "Reset fingerprint"
				else
					menu_new_print "$1" "$INPUT2" 2
				fi
			;;
			u|U)
				if [ "$(get_file_value $LATEFILE "OPTIONWEB=")" == 0 ]; then
					menu_update_print "Update fingerprints list"
				else
					menu_new_print "$1" "$INPUT2" 2
				fi
			;;
			b|B)
				INPUT=""
				break
			;;
			e|E)	exit_fn
			;;
			""|[[:blank:]]*)	blank_input 2
			;;
			*)
				if [ "${#INPUT2}" -lt 10 ]; then
					invalid_input 5 2
				else
					menu_new_print "$1" "$INPUT2" 2
				fi
			;;
		esac
	done
}

# Third menu level - pick fingerprint
menu_pick_print() {
	INPUT3=""
	OEMLIST=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			# Load the list of fingerprint files
			log_handler "Loading fingerprints list v$(get_file_value $PRINTSLOC "PRINTSV=")."
			OEMLIST="$(ls $PRINTFILES | sed 's|\.sh||g')"
			if [ "$OEMLIST" ]; then
				# Check for custom fingerprints list
				if [ -s "$CSTMPRINTS" ] && [ ! -f "$CSTMFILE" ]; then
					log_handler "Found custom fingerprints list."
					format_file $CSTMPRINTS
					log_handler "Creating custom prints file."
					cat $CSTMPRINTS >> $LOGFILE 2>&1 && echo "" >> $LOGFILE 2>&1
					echo -e "PRINTSLIST=\"" >> $CSTMFILE
					cat $CSTMPRINTS >> $CSTMFILE
					echo -e "\"" >> $CSTMFILE
					# Reload the list with new files
					OEMLIST="$(ls $PRINTFILES | sed 's|\.sh||g')"
				fi
				ITEMCOUNT=1
				menu_header "${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")\n Select an option below."
				echo ""
				for ITEM in $OEMLIST; do
					echo "${G}$ITEMCOUNT${N} - $ITEM"
					ITEMCOUNT=$(($ITEMCOUNT+1))
				done
				echo "${G}b${N} - Go back"
				echo ""
				echo -n "Enter '${G}e${N}' to exit: "
				read -r INPUT3
			else
				log_handler "No fingerprints list."
				collect_logs "issue"
				menu_header "${C}$1${N}\n Something's wrong!"
				echo "Hm... That's not right."
				echo ""
				echo "There is currently no fingerprints list"
				echo "available. Try updating it manually."
				echo ""
				echo "If the issue persists, report it in the"
				echo "support thread @ XDA, ${R}with logs!${C}"
				echo ""
				echo "Logs have automatically been saved to"
				echo "your internal storage ${R}(propslogs.tar.gz)${C}."
				echo ""
				echo -n "Press enter to continue..."
				read -r INPUTTMP
				INPUT2=""
				break
			fi
		fi
		if [ "$INPUT3" -ge 1 ] && [ "$INPUT3" -lt "$ITEMCOUNT" ]; then
			ITEMCOUNT=1
			for ITEM in $OEMLIST; do
				if [ "$ITEMCOUNT" == "$INPUT3" ]; then
					menu_pick_print_sub "$1" "$ITEM"
					break
				fi
				ITEMCOUNT=$(($ITEMCOUNT+1))
			done
		elif [ "$INPUT3" == "b" ] || [ "$INPUT3" == "B" ]; then
			INPUT2=""
			break
		elif [ "$INPUT3" == "e" ] || [ "$INPUT3" == "E" ]; then
			exit_fn
		else
			invalid_input 1 3
		fi
	done
}

# Fourth menu level - pick fingerprint
menu_pick_print_sub() {
	# Loading fingerprints
	TMPFILE=$PRINTFILES/$2.sh
	if [ -f "$TMPFILE" ]; then
		. $TMPFILE
		INPUT4=""
	else
		menu_header "${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")\n Select an option below."
		log_handler "Can't find '$TMPFILE'."
		collect_logs "issue"
		echo "Oh no! Something went wrong..."
		echo ""
		echo "Can't find the fingerprints file."
		echo "Try updating it manually."
		echo ""
		echo "If the issue persists, report it in the"
		echo "support thread @ XDA, ${R}with logs!${C}"
		echo ""
		echo "Logs have automatically been saved to"
		echo "your internal storage ${R}(propslogs.tar.gz)${C}."
		echo ""
		echo -n "Press enter to continue..."
		read -r INPUTTMP
		INPUT4="b"
	fi
	while true
	do
		if [ -z "$INPUT4" ]; then
			ITEMCOUNT=1
			menu_header "${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")\n Select an option below."
			echo ""
			SAVEIFS=$IFS
			IFS=$(echo -en "\n\b")
			for ITEM in $PRINTSLIST; do
				if [ "$(get_first $ITEM)" == "$2" ] || [ "$2" == "Custom" ]; then
					echo "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")"
					ITEMCOUNT=$(($ITEMCOUNT+1))
				fi
			done
			IFS=$SAVEIFS
			echo "${G}b${N} - Go back"
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT4
		fi
		if [ "$INPUT4" -ge 1 ] && [ "$INPUT4" -lt "$ITEMCOUNT" ]; then
			ITEMCOUNT=1
			SAVEIFS=$IFS
			IFS=$(echo -en "\n\b")
			for ITEM in $PRINTSLIST; do
				if [ "$ITEMCOUNT" == "$INPUT4" ]; then
					menu_new_print "$1" $(get_eq_right "$ITEM")					
					break
				fi
				ITEMCOUNT=$(($ITEMCOUNT+1))
			done
			IFS=$SAVEIFS
		elif [ "$INPUT4" == "b" ] || [ "$INPUT4" == "B" ]; then
			INPUT3=""
			break
		elif [ "$INPUT4" == "e" ] || [ "$INPUT4" == "E" ]; then
			exit_fn
		else
			invalid_input 1 4
		fi
	done
}

# Fifth menu level - fingerprint
menu_new_print() {
	INPUT5=""
	PRINTDISP="$(get_print_display $2)"
	while true
	do
		if [ -z "$INPUT5" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "You are about to use the following as your device's fingerprint."
			echo ""
			get_device_used $2
			echo "${V}$PRINTDISP${N}"
			echo ""
			echo "Make sure that it is correct before continuing."
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT5
		fi
		case "$INPUT5" in
			y|Y)
				change_print "$1" "$2"
				break
			;;
			n|N)
				INPUT2=""
				INPUT3=""
				INPUT4=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 5
			;;
		esac
	done
}

# Third menu level - Reset fingerprint
menu_reset_print() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset the device"
			echo "fingerprint to the default value."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)	
				reset_print "$1"
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Update fingerprints list
menu_update_print() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")"
			echo ""
			echo "Do you want to check online if there"
			echo "is an update to the fingerprints list?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)	
				download_prints "manual"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# ======================== Edit props files ========================
# Second menu level - prop files
menu_edit_prop_files() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			# Checks if file values are "safe"
			if [ "$(get_file_value $LATEFILE "FILESAFE=")" == 1 ]; then
				echo "Prop file modification currently disabled,"
				echo "since all relevant file values are \"safe\"."
				echo ""
				if [ "$2" == "p" ]; then
					echo "Nothing to do... Exiting."
					exit 0
				else
					echo "Nothing to do... Returning to main menu."
					sleep 3
					INPUT=""
					break
				fi
			else
				# Checks if editing prop files is enabled and/or active
				if [ "$(get_file_value $LATEFILE "BUILDEDIT=")" == 1 ] || [ "$(get_file_value $LATEFILE "DEFAULTEDIT=")" == 1 ]; then
					if [ "$(get_file_value $LATEFILE "BUILDPROPENB=")" == 1 ]; then
						echo "This will revert the values in build.prop"
						echo "and default.prop to their original values."
					else
						echo "This will revert the values in"
						echo "default.prop to the original values."
					fi
				else
					if [ "$(get_file_value $LATEFILE "BUILDPROPENB=")" == 1 ]; then
						echo "This will change values in build.prop"
						echo "and default.prop to match the values"
					else
						echo "This will change values in"
						echo "default.prop to match the values"
					fi
					echo "set by MagiskHide or this module."
				fi
				echo ""
				if [ "$(get_file_value $LATEFILE "BUILDPROPENB=")" == 0 ]; then
					echo "Please note that build.prop editing is"
					echo "disabled because of a conflicting module."
					echo ""
				fi
				echo "Do you want to continue?"
				if [ "$(get_file_value $LATEFILE "BUILDEDIT=")" == 1 ] || [ "$(get_file_value $LATEFILE "DEFAULTEDIT=")" == 1 ]; then
					echo ""
					echo "Enter ${G}r${N} to re-apply the settings."
					echo "This option is only useful if there's been"
					echo "an update to the \"Improved hiding\" feature."
				fi
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				if [ "$2" == "p" ]; then
					echo -n "Enter ${G}y${N}(es) or ${G}n${N}(o): "
					LOGTXT=" (option -p)"
					INV1=2
					INV2=1
				else
					echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
					LOGTXT=""
					INV1=3
					INV2=2
				fi
				read -r INPUT2
			fi
		fi
		case "$INPUT2" in
			y|Y)
				if [ "$(get_file_value $LATEFILE "BUILDEDIT=")" == 1 ] || [ "$(get_file_value $LATEFILE "DEFAULTEDIT=")" == 1 ]; then
					reset_prop_files "$1" "$2" "$LOGTXT"
				else
					edit_prop_files "$1" "$2" "$LOGTXT"
				fi
				break
			;;
			n|N)
				if [ "$2" == "p" ]; then
					exit_fn
				else
					INPUT=""
					break
				fi
			;;
			r|R)
				if [ "$(get_file_value $LATEFILE "BUILDEDIT=")" == 1 ] || [ "$(get_file_value $LATEFILE "DEFAULTEDIT=")" == 1 ]; then
					edit_prop_files "$1" "$2" "$LOGTXT"
				else
					invalid_input $INV1 $INV2
				fi	
			;;
			e|E)
				if [ "$2" == "p" ]; then
					invalid_input $INV1 $INV2
				else
					exit_fn
				fi
			;;
			*)	invalid_input $INV1 $INV2
			;;
		esac
	done
}

# ======================== MagiskHide Props ========================
# Second menu level - MagiskHide props
menu_magiskhide_props() {
	INPUT2=""
	while true
	do
		ACTIVE="${G} (active)${N}"
		DEBUGGABLETXT=""
		SECURETXT=""
		TYPETXT=""
		TAGSTXT=""
		SELINUXTXT=""
		if [ -z "$INPUT2" ]; then
			if [ "$(get_file_value $LATEFILE "REDEBUGGABLE=")" == "true" ]; then
				DEBUGGABLETXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "RESECURE=")" == "true" ]; then
				SECURETXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "RETYPE=")" == "true" ]; then
				TYPETXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "RETAGS=")" == "true" ]; then
				TAGSTXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "RESELINUX=")" == "true" ]; then
				SELINUXTXT=$ACTIVE
			fi
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""
			echo "Change the sensitive props set by MagiskHide."
			echo ""
			echo "${G}1${N} - ro.debuggable${DEBUGGABLETXT}"
			echo "${G}2${N} - ro.secure${SECURETXT}"
			echo "${G}3${N} - ro.build.type${TYPETXT}"
			echo "${G}4${N} - ro.build.tags${TAGSTXT}"
			echo "${G}5${N} - ro.build.selinux${SELINUXTXT}"
			if [ "$(get_file_value $LATEFILE "PROPCOUNT=")" -gt 1 ]; then
				echo "${G}r${N} - Reset all props"
			fi
			echo "${G}b${N} - Go back to main menu"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT2
		fi
		case "$INPUT2" in
			1)	menu_change_prop "ro.debuggable" $CURRDEBUGGABLE $ORIGDEBUGGABLE $MODULEDEBUGGABLE		
			;;
			2)	menu_change_prop "ro.secure" $CURRSECURE $ORIGSECURE $MODULESECURE
			;;
			3)	menu_change_prop "ro.build.type" $CURRTYPE $ORIGTYPE $MODULETYPE
			;;
			4)	menu_change_prop "ro.build.tags" $CURRTAGS $ORIGTAGS $MODULETAGS
			;;
			5)	menu_change_prop "ro.build.selinux" $CURRSELINUX $ORIGSELINUX $MODULESELINUX
			;;
			r|R)	
				if [ "$(get_file_value $LATEFILE "PROPCOUNT=")" -gt 1 ]; then
					menu_reset_prop_all "Reset all props"
				else
					invalid_input 1 2
				fi
			;;
			b|B)
				INPUT=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# Third menu level - MagiskHide props
menu_change_prop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			PROP=$(get_prop_type "$1")
			REPROP=$(echo "RE${PROP}" | tr '[:lower:]' '[:upper:]')
			menu_header "${C}$1${N}"
			echo ""
			# Checks if the prop exists
			if [ "$2" ]; then
				if [ "$4" ] && [ "$(get_file_value $LATEFILE "${REPROP}=")" == "true" ]; then
					PROPMODULETXT=", by this module"
					BACKTXT=" back"
				else
					PROPMODULETXT=""
					BACKTXT=""
				fi
				echo "Currently set to ${C}$2${N}${PROPMODULETXT}."				
				if [ "$2" != "$3" ]; then
					echo "The original value is ${C}$3${N}."
				fi
				echo ""
				safe_props "$1" $2
				change_to "$1" $2
				if [ "$SAFE" == 1 ]; then
					echo "You currently have the safe value set."
					echo "Are you sure you want to change it$BACKTXT to ${C}$CHANGE${N}?"
				else
					echo "Do you want to change it${BACKTXT} to ${C}$CHANGE${N}?"
				fi
				echo ""
				echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
				read -r INPUT3
			else
				INPUT3="n"
				echo "This prop doesn't currently exist on your system."
				echo ""
				echo "Nothing to do... Returning to main menu."
				sleep 3
			fi
		fi
		case "$INPUT3" in
			y|Y)
				if [ "$PROPMODULETXT" ]; then
					menu_reset_prop "Reset $1" "$1"
				else
					change_prop "$1" $CHANGE
				fi
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Reset all MagiskHide props
menu_reset_prop_all() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset all prop"
			echo "values to default values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)	
				reset_prop_all "$1"
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Reset specific MagiskHide prop
menu_reset_prop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset $2"
			echo "to it's default value."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)	
				reset_prop "$2"
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# ======================== Custom Props ========================
# Second menu level - Custom props
menu_custom_props() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			ITEMCOUNT=1
			if [ "$(get_file_value $LATEFILE "OPTIONLATE=")" == 0 ]; then
				DEFSTAGETXT=" (post-fs-data)"
			else
				DEFSTAGETXT=" (late_start service)"
			fi
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""			
			if [ "$(get_file_value $LATEFILE "CUSTOMEDIT=")" == 0 ] && [ "$CUSTOMPROPS" -o "$CUSTOMPROPSPOST" -o "$CUSTOMPROPSLATE" ]; then
				CTRLSET=0
				echo "You have ${C}custom props set${N},"
				echo "but the option is ${R}not activated${N}."
				echo ""
				echo "Do you want to activate it (enter ${G}r${N} to reset)?"
				echo ""
				echo -n "Enter ${G}y${N}(es), ${G}n${N}(o), ${G}r${N}(eset) or ${G}e${N}(xit): "
				read -r INPUT2
			else
				CTRLSET=1
				echo "Set or edit custom prop values for your device."
				echo ""
				if [ "$CUSTOMPROPS" ] || [ "$CUSTOMPROPSPOST" ] || [ "$CUSTOMPROPSLATE" ]; then
					if [ "$CUSTOMPROPS" ]; then
						echo "${C}Default boot stage${G}${DEFSTAGETXT}${N}"
						for ITEM in $CUSTOMPROPS; do
							echo "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")"
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					fi
					if [ "$CUSTOMPROPSPOST" ]; then
						echo ""
						echo "${C}post-fs-data boot stage${N}"
						for ITEM in $CUSTOMPROPSPOST; do
							echo "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")"
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					fi
					if [ "$CUSTOMPROPSLATE" ]; then
						echo ""
						echo "${C}late_start service boot stage${N}"
						for ITEM in $CUSTOMPROPSLATE; do
							echo "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")"
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					fi
				else
					echo "Currently no custom props set."
					echo "Please add one by selecting"
					echo "\"New custom prop\" below."
				fi
				echo ""
				echo "${G}n${N} - New custom prop"
				if [ "$CUSTOMPROPS" ] || [ "$CUSTOMPROPSPOST" ] || [ "$CUSTOMPROPSLATE" ]; then
					echo "${G}r${N} - Reset all custom props"
				fi
				echo "${G}b${N} - Go back to main menu"
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter '${G}e${N}' to exit: "
				read -r INPUT2
			fi
			if [ "$INPUT2" -ge 1 -a "$INPUT2" -le "$ITEMCOUNT" ] || [ "$INPUT2" == "y" -a "@CTRLSET" == 0 ] || [ "$INPUT2" == "Y" -a "@CTRLSET" == 0 ]; then
				if [ "$CTRLSET" == 1 ]; then
					ITEMCOUNT=1
					for ITEM in $CUSTOMPROPSLIST; do
						if [ "$ITEMCOUNT" == "$INPUT2" ]; then
							menu_edit_custprop "$(get_eq_left "$ITEM")"
							break
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				elif [ "$CTRLSET" == 0 ]; then
					replace_fn CUSTOMEDIT 0 1 $LATEFILE
					INPUT=""
					break
				fi
			elif [ "$INPUT2" == "n" ] || [ "$INPUT2" == "N" ]; then
				if [ "$CTRLSET" == 1 ]; then
					menu_new_custprop "New custom prop"
				elif [ "$CTRLSET" == 0 ]; then
					INPUT=""
					break
				fi
			elif [ "$INPUT2" == "r" ] || [ "$INPUT2" == "R" ]; then
				if [ "$CTRLSET" == 1 ]; then
					menu_reset_all_custprop "Reset all custom props"
				elif [ "$CTRLSET" == 0 ]; then
					menu_reset_all_custprop "Reset all custom props"
				fi
			elif [ "$INPUT2" == "b" ] || [ "$INPUT2" == "B" ]; then
				if [ "$CTRLSET" == 1 ]; then
					INPUT=""
					break
				elif [ "$CTRLSET" == 0 ]; then
					invalid_input 4 2
				fi
			elif [ "$INPUT2" == "e" ] || [ "$INPUT2" == "E" ]; then
				exit_fn
			else
				if [ "$CTRLSET" == 1 ]; then
					invalid_input 1 2
				elif [ "$CTRLSET" == 0 ]; then
					invalid_input 4 2
				fi
			fi
		fi
	done
}

# Third menu level - Edit custom prop
menu_edit_custprop() {
	INPUT3=""
	if [ "$(echo $CUSTOMPROPS | grep $1)" ]; then
		STAGETXT=" ${G}(default)${N}"
	elif [ "$(echo $CUSTOMPROPSPOST | grep $1)" ]; then
		STAGETXT=" ${G}(post-fs-data)${N}"
	elif [ "$(echo $CUSTOMPROPSLATE | grep $1)" ]; then
		STAGETXT=" ${G}(late_start service)${N}"
	else
		TMPBSTAGE=""
	fi
	while true
	do
		if [ -z "$INPUT3" ]; then
			for ITEM in $CUSTOMPROPSLIST; do
				TMPITEM=$( echo $(get_eq_right "$ITEM") | sed 's|_sp_| |g')
				if [ "$(get_eq_left "$ITEM")" == "$1" ]; then
					if [ "$TMPITEM" == "$(resetprop $1)" ]; then
						PROPNOTSET=0
						SETPROPVALUE="$TMPITEM"
					else
						PROPNOTSET=1
					fi
					break
				fi
			done
			menu_header "${C}$1${N}"
			echo ""
			echo "The current value for"
			echo "${C}'$1'${N} is:"
			echo ""
			echo "${C}$(resetprop $1)${N}"
			if [ "$PROPNOTSET" == 0 ]; then
				echo "(Set by this module.)"
				echo ""
				echo "Enter a new value or select"
				echo "from the options below."
				echo ""
				echo "${G}s${N} - Prop boot stage$STAGETXT"
				echo "${G}r${N} - Reset prop"
			else
				echo "${R}Not yet set by this module. Please reboot to set.${N}"
				if [ "$(get_file_value $LATEFILE "OPTIONLATE=")" == 0 ] || [ "$STAGETXT" == " ${G}(post-fs-data)${N}" ]; then
					echo ""
					echo "This might be caused by the prop being set to early."
					echo "If the above state does not change after a reboot,"
					echo "try changing the boot stage when the prop is set"
					echo "to late_start service."
				fi
				echo ""
				echo "${G}r${N} - Reboot"
			fi
			echo "${G}b${N} - Go back."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			s|S)
				menu_bootstage_custprop "$1"
			;;
			r|R)
				if [ "$PROPNOTSET" == 0 ]; then
					menu_reset_custprop "$1" "$SETPROPVALUE"
					break
				else
					reboot_fn "Reboot device" "reboot"
				fi
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)
				if [ "$PROPNOTSET" == 0 ]; then
					menu_set_custprop "$1" "$INPUT3" "$(resetprop $1)"
					break
				else
					invalid_input 1 3
				fi
			;;
		esac
	done
}

# Third menu level - New custom prop
menu_new_custprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the prop to set,"
			echo "or ${G}b${N} to go back."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			b|B)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			""|[[:blank:]]*)	blank_input 3
			;;
			*)
				if [ "$(echo $PROPSLIST | grep -o $INPUT3)" ] || [ "$(echo $CUSTOMPROPSLIST | grep -o $INPUT3)" ]; then
					menu_magiskhide_custprop "$INPUT3"
				else
					menu_set_new_custprop "$INPUT3"
					break
				fi
			;;
		esac
	done
}

# Third menu level - Reset all custom props
menu_reset_all_custprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset all"
			echo "custom prop values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_all_custprop
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Fourth menu level - MagiskHide custom prop and duplicate props
menu_magiskhide_custprop() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			if [ "$(echo $PROPSLIST | grep -o $1)" ]; then
				echo "That prop, ${C}$1${N}, is"
				echo "one of the sensitive props already set"
				echo "by MagiskHide. No need to do it again."
			else
				echo "That prop, ${C}$1${N}, is"
				echo "already on your list of custom props."
				echo "No need to set it again."
			fi
			echo ""
			echo "${G}b${N} - Go back."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			b|B)
				INPUT3=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 1 4
			;;
		esac
	done
}

# Fourth menu level - Set new custom prop
menu_set_new_custprop() {
	INPUT4=""
	TMPPROP=$(resetprop "$1")
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the value to set"
			echo "${C}$1${N} to,"
			echo "or select from the options below."
			echo ""
			if [ "$TMPPROP" ]; then
				echo "The current value is:"
				echo "${C}$TMPPROP${N}"
			else
				echo "This prop currently doesn't exist on your system."
			fi
			echo ""
			echo "${G}b${N} - Go back."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			b|B)
				INPUT2=""
				INPUT3=""
				break
			;;
			e|E)	exit_fn
			;;
			""|[[:blank:]]*)	blank_input 4
			;;
			*)
				menu_set_custprop "$1" "$INPUT4" "$TMPPROP"
				INPUT2=""
				INPUT3=""
				break
			;;
		esac
	done
}

# Fourth menu level - Custom prop boot stage
menu_bootstage_custprop() {
	INPUT4=""
	if [ "$(echo $CUSTOMPROPS | grep $1)" ]; then
		TMPBSTAGE="default"
		DEFAULTTXT="${G} (current)${N}"
		POSTTXT=""
		LATETXT=""
	elif [ "$(echo $CUSTOMPROPSPOST | grep $1)" ]; then
		TMPBSTAGE="post-fs-data"
		DEFAULTTXT=""
		POSTTXT="${G} (current)${N}"
		LATETXT=""
	elif [ "$(echo $CUSTOMPROPSLATE | grep $1)" ]; then
		TMPBSTAGE="late_start service"
		DEFAULTTXT=""
		POSTTXT=""
		LATETXT="${G} (current)${N}"
	else
		TMPBSTAGE=""
	fi
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Select what boot stage"
			echo "${C}$1${N}"
			echo "should be set in."
			echo ""
			echo "Currently, the"
			echo "${G}${TMPBSTAGE}${N}"
			echo "boot stage is used."
			echo ""
			echo "Select an option below."
			echo ""
			echo "${G}1${N} - Default${DEFAULTTXT}"
			echo "${G}2${N} - post-fs-data${POSTTXT}"
			echo "${G}3${N} - late_start service${LATETXT}"
			echo "${G}b${N} - Go back."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			1)
				if [ "$DEFAULTTXT" ]; then
					active_option
				else
					change_bootstage_custprop "$1" "default"
					INPUT3=""
					break
				fi
			;;
			2)
				if [ "$POSTTXT" ]; then
					active_option
				else
					change_bootstage_custprop "$1" "post"
					INPUT3=""
					break
				fi
			;;
			3)
				if [ "$LATETXT" ]; then
					active_option
				else
					change_bootstage_custprop "$1" "late"
					INPUT3=""
					break
				fi
			;;
			b|B)
				INPUT3=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 1 4
			;;
		esac
	done
}

# Fourth menu level - Reset custom prop
menu_reset_custprop() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset ${C}$1${N}"
			echo "to its original value."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				reset_custprop "$1" "$2"
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 4
			;;
		esac
	done
}

# Fifth menu level - Set custom prop
menu_set_custprop() {
	PROPSTAGE="default"
	DEFAULTTXT=" ${G}(current)${N}"
	POSTTXT=""
	LATETXT=""
	INPUT5=""
	while true
	do
		if [ -z "$INPUT5" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will set ${C}$1${N} to:"
			echo "${C}$2${N}"
			echo ""
			echo "Pick an option below to change"
			echo "what boot stage the prop will"
			echo "be set in:"
			echo ""
			echo "${G}1${N} - Default${DEFAULTTXT}"
			echo "${G}2${N} - post-fs-data${POSTTXT}"
			echo "${G}3${N} - late_start service${LATETXT}"
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT5
		fi
		case "$INPUT5" in
			1)
				if [ "$DEFAULTTXT" ]; then
					active_option
				else
					PROPSTAGE="default"
					DEFAULTTXT=" ${G}(current)${N}"
					POSTTXT=""
					LATETXT=""
					INPUT5=""
				fi
			;;
			2)
				if [ "$POSTTXT" ]; then
					active_option
				else
					PROPSTAGE="post"
					DEFAULTTXT=""
					POSTTXT=" ${G}(current)${N}"
					LATETXT=""
					INPUT5=""
				fi
			;;
			3)
				if [ "$LATETXT" ]; then
					active_option
				else
					PROPSTAGE="late"
					DEFAULTTXT=""
					POSTTXT=""
					LATETXT=" ${G}(current)${N}"
					INPUT5=""
				fi
			;;
			y|Y)
				set_custprop "$1" "$2" "$PROPSTAGE" "$3"
				INPUT2=""
				INPUT3=""
				INPUT4=""
				break
			;;
			n|N)
				INPUT4=""
				INPUT5=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 5
			;;
		esac
	done
}

# ======================== Delete Props ========================
# Second menu level - Delete props
menu_delete_props() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			ITEMCOUNT=1
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""			
			if [ "$(get_file_value $LATEFILE "DELEDIT=")" == 0 ] && [ "$DELETEPROPS" ]; then
				CTRLSET=0
				echo "You have a list of ${C}props to delete${N},"
				echo "but the option is ${R}not activated${N}."
				echo ""
				echo "Do you want to activate it (enter ${G}r${N} to reset)?"
				echo ""
				echo -n "Enter ${G}y${N}(es), ${G}n${N}(o), ${G}r${N}(eset) or ${G}e${N}(xit): "
				read -r INPUT2
			else
				CTRLSET=1
				echo "Delete prop values on your device."
				echo ""
				if [ "$DELETEPROPS" ]; then
					echo "Select a prop below to reset it."
					echo ""
					for ITEM in $DELETEPROPS; do
						echo "${G}$ITEMCOUNT${N} - $ITEM"
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				else
					echo "Currently no props set for removal."
					echo "Please add one by selecting"
					echo "\"New prop\" below."
				fi
				echo ""
				echo "${G}n${N} - New prop"
				if [ "$CUSTOMPROPS" ]; then
					echo "${G}r${N} - Reset all props"
				fi
				echo "${G}b${N} - Go back to main menu"
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter '${G}e${N}' to exit: "
				read -r INPUT2
			fi
			if [ "$INPUT2" -ge 1 -a "$INPUT2" -le "$ITEMCOUNT" ] || [ "$INPUT2" == "y" -a "@CTRLSET" == 0 ] || [ "$INPUT2" == "Y" -a "@CTRLSET" == 0 ]; then
				if [ "$CTRLSET" == 1 ]; then
					ITEMCOUNT=1
					for ITEM in $DELETEPROPS; do
						if [ "$ITEMCOUNT" == "$INPUT2" ]; then
							menu_reset_delprop "$ITEM"
							break
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				elif [ "$CTRLSET" == 0 ]; then
					replace_fn DELEDIT 0 1 $LATEFILE
					INPUT=""
					break
				fi
			elif [ "$INPUT2" == "n" ] || [ "$INPUT2" == "N" ]; then
				if [ "$CTRLSET" == 1 ]; then
					menu_new_delprop "New prop"
				elif [ "$CTRLSET" == 0 ]; then
					INPUT=""
					break
				fi
			elif [ "$INPUT2" == "r" ] || [ "$INPUT2" == "R" ]; then
				if [ "$CTRLSET" == 1 ]; then
					menu_reset_all_delprop "Reset all props"
				elif [ "$CTRLSET" == 0 ]; then
					menu_reset_all_delprop "Reset all props"
				fi
			elif [ "$INPUT2" == "b" ] || [ "$INPUT2" == "B" ]; then
				if [ "$CTRLSET" == 1 ]; then
					INPUT=""
					break
				elif [ "$CTRLSET" == 0 ]; then
					invalid_input 4 2
				fi
			elif [ "$INPUT2" == "e" ] || [ "$INPUT2" == "E" ]; then
				exit_fn
			else
				if [ "$CTRLSET" == 1 ]; then
					invalid_input 1 2
				elif [ "$CTRLSET" == 0 ]; then
					invalid_input 4 2
				fi
			fi
		fi
	done
}

# Third menu level - Reset deleted prop
menu_reset_delprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will remove ${C}$1${N}"
			echo "from the list of props to delete."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_delprop "$1"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - New prop to delete
menu_new_delprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the prop to delete,"
			echo "or ${G}b${N} to go back."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			b|B)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			""|[[:blank:]]*)	blank_input 3
			;;
			*)
				menu_set_new_delprop "$INPUT3"
				break
			;;
		esac
	done
}

# Third menu level - Reset all deleted props
menu_reset_all_delprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset the entire"
			echo "list of props to delete."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_all_delprop
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Fourth menu level - Set new prop to delete
menu_set_new_delprop() {
	INPUT4=""
	TMPPROP=$(resetprop "$1")
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			if [ "$TMPPROP" ]; then
				echo "The current value is:"
				echo "${C}$TMPPROP${N}"
				echo ""
				echo "This will delete"
				echo "${C}$1${N}"
				echo "from your system."
			else
				echo "This prop currently doesn't exist on your system."
				echo ""
				echo "Nothing to do... Returning to main menu."
				sleep 3
				INPUT2=""
				INPUT3=""
				break
			fi
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				set_delprop "$1"
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 4
			;;
		esac
	done
}

# ======================== Options ========================
# Second menu level - Options
menu_options() {
	INPUT2=""
	while true
	do
		COLOURTXT=""
		PRINTSCHKTXT=""
		if [ -z "$INPUT2" ]; then
			if [ "$(get_file_value $LATEFILE "OPTIONLATE=")" == 1 ]; then
				BOOTTXT="late_start service"
			else
				BOOTTXT="post-fs-data"
			fi
			if [ "$(get_file_value $LATEFILE "OPTIONCOLOUR=")" == 1 ]; then
				COLOURTXT="enabled"
				CC=${G}
			else
				COLOURTXT="disabled"
				CC=${R}
			fi
			if [ "$(get_file_value $LATEFILE "OPTIONWEB=")" == 1 ]; then
				PRINTSCHKTXT="enabled"
				CP=${G}
			else
				PRINTSCHKTXT="disabled"
				CP=${R}
			fi
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""
			echo "${G}1${N} - Boot stage (currently ${C}${BOOTTXT}${N})"
			echo "${G}2${N} - Script colours (currently ${CC}${COLOURTXT}${N})"
			echo "${G}3${N} - Fingerprints list check (currently ${CP}${PRINTSCHKTXT}${N})"
			echo "${G}r${N} - Reset all settings"
			if [ "$2" != "s" ]; then
				echo "${G}b${N} - Go back to main menu"
			fi
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT2
		fi
		case "$INPUT2" in
			1)	menu_options_bootstage "Boot stage" "$BOOTTXT"
			;;
			2)	menu_options_colour "Script colours" "$COLOURTXT"
			;;
			3)	menu_options_printschk "Fingerprints list check" "$PRINTSCHKTXT"
			;;
			r|R)	menu_options_reset "Reset all settings"
			;;
			b|B)
				if [ "$2" == "s" ]; then
					invalid_input 1 2
				else
					INPUT=""
					break
				fi
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# Third menu level - Options, boot stage
menu_options_bootstage() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$2" == "late_start service" ]; then
				TMPTXT="post-fs-data"
				OPTCURR=1
				OPTNEW=0
			else
				TMPTXT="late_start service"
				OPTCURR=0
				OPTNEW=1
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo "Current boot stage is ${G}$2${N}."
			echo ""
			echo "Do you want to change it to ${C}$TMPTXT${N}?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				log_handler "Boot stage changed to ${TMPTXT}."
				replace_fn OPTIONLATE $OPTCURR $OPTNEW $LATEFILE
				INPUT2=""
				reboot_fn "$1"
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Options, colour
menu_options_colour() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$2" == "enabled" ]; then
				TMPTXT="disable"
				OPTCURR=1
				OPTNEW=0
			else
				TMPTXT="enable"
				OPTCURR=0
				OPTNEW=1
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo "Script colours are currently ${G}$2${N}d."
			echo ""
			echo "Do you want to ${C}$TMPTXT${N} them?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				log_handler "The script colour option was ${TMPTXT}d."
				replace_fn OPTIONCOLOUR $OPTCURR $OPTNEW $LATEFILE
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Options, prints list check
menu_options_printschk() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$2" == "enabled" ]; then
				TMPTXT="disable"
				OPTCURR=1
				OPTNEW=0
			else
				TMPTXT="enable"
				OPTCURR=0
				OPTNEW=1
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo "Automatic updating of the fingerprints"
			echo "list is currently ${G}$2${N}."
			echo ""
			echo "Do you want to ${C}$TMPTXT${N} it?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				log_handler "The script prints list check option was ${TMPTXT}d."
				replace_fn OPTIONWEB $OPTCURR $OPTNEW $LATEFILE
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Options, reset all options
menu_options_reset() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset all script settings"
			echo "to their default values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				log_handler "Resetting all script settings."
				OPTLCURR=$(get_file_value $LATEFILE "OPTIONLATE=")
				OPTCCURR=$(get_file_value $LATEFILE "OPTIONCOLOUR=")
				OPTWCURR=$(get_file_value $LATEFILE "OPTIONWEB=")
				replace_fn OPTIONLATE $OPTLCURR 1 $LATEFILE
				replace_fn OPTIONCOLOUR $OPTCCURR 1 $LATEFILE
				replace_fn OPTIONWEB $OPTWCURR 1 $LATEFILE
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# ======================== Logs ========================
# Second menu level - Logs
menu_logs() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will package the Magisk log and the"
			echo "module specific log files, together"
			echo "with the device default build.prop"
			echo "file and all the current prop values"
			echo "to a file and save it on your device."
			echo ""
			echo "Upload the file to the support thread"
			echo "@ XDA, with a detailed description if"
			echo "you're having issues."
			echo ""
			echo "Do you want to contine?"
			echo ""
			if [ "$2" == "l" ]; then
				echo -n "Enter ${G}y${N}(es) or ${G}n${N}(o): "
			else
				echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			fi
			read -r INPUT2
		fi
		case "$INPUT2" in
			y|Y)
				collect_logs "$1" "$2"
				INPUT=""
				break
			;;
			n|N)
				if [ "$2" == "l" ]; then
					exit_fn
				else
					INPUT=""
					break
				fi
			;;
			e|E)
				if [ "$2" == "l" ]; then
					invalid_input 1 2
				else
					exit_fn
				fi
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# ======================== Reset all options and settings ========================
# Second menu level - Reset all options and settings
reset_everything() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "All module options and settings"
			echo "will be reset to the default values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			if [ "$2" == "r" ]; then
				echo -n "Enter ${G}y${N}(es) or ${G}n${N}(o): "
				LOGTXT=" (option -r)"
				INV1=2
				INV2=1
			else
				echo -n "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
				LOGTXT=""
				INV1=3
				INV2=2
			fi
			read -r INPUT2
		fi
		case "$INPUT2" in
			y|Y)	
				log_handler "Resetting all module settings$LOGTXT."
				reset_fn
				reboot_fn "$1" "$2"
				break
			;;
			n|N)	
				if [ "$2" == "r" ]; then
					exit_fn
				else
					INPUT=""
					break
				fi
			;;
			e|E)	
				if [ "$2" == "r" ]; then
					invalid_input $INV1 $INV2
				else
					exit_fn
				fi
			;;
			*)	invalid_input $INV1 $INV2
			;;
		esac
	done
}

# ====================================================
# =================== Script check ===================
# ====================================================

ISSUECHK=0
if [ "$ISSUECHK" == 0 ] && [ ! -f "$LATEFILE" ]; then
	log_handler "late_start service boot script can't be found."
	ISSUECHK=1
	ISSUETXT="The late_start service boot script can't be found.\n\n Please reboot your device to reset."
fi

orig_check
if  [ "$ISSUECHK" == 0 ] && [ "$ORIGLOAD" == 0 ]; then
	log_handler "Original prop values are not loaded in late_start service boot script."
	ISSUECHK=1
	ISSUETXT="The original prop values are not loaded,\n possibly due to a full reset of the module,\n or something has gone wrong.\n\n Please reboot your device to reset."
fi

script_ran_check
if [ "$ISSUECHK" == 0 ] && [ "$POSTCHECK" == 0 ] && [ "$LATECHECK" == 0 ]; then
	log_handler "None of the boot scripts ran during boot."
	ISSUECHK=1
	ISSUETXT="None of the boot scripts appear\n to have run during boot.\n\n This means the module won't work.\n\n Please reboot your device and see if\n they do run."
elif [ "$ISSUECHK" == 0 ] && [ "$POSTCHECK" == 0 ]; then
	log_handler "The post-fs-data boot script did not run during boot."
	ISSUECHK=1
	ISSUETXT="The post-fs-data boot script does not\n appear to have run during boot.\n\n This means the module won't work.\n\n Please reboot your device and see if\n it does run."
elif [ "$ISSUECHK" == 0 ] && [ "$LATECHECK" == 0 ]; then
	log_handler "The late_start service boot script did not run during boot."
	ISSUECHK=1
	ISSUETXT="The late_start service boot script does not\n appear to have run during boot.\n\n This means the module won't work.\n\n Please reboot your device and see if\n it does run."
fi

if [ "$ISSUECHK" == 1 ]; then
	collect_logs "issue"
	reboot_fn "${ISSUETXT}\n\n If the issue persists after a reboot,\n please report the issue, ${R}with logs!${C}\n\n Logs have automatically been saved\n to your internal storage\n ${R}(propslogs.tar.gz)${C}.\n\n If the automatic collection failed,\n please collect the logs manually.\n\n ${G}See the documentation for details.${N}" "reset-script"
fi

# ==================================================
# ================ Find used values ================
# ==================================================

all_values

# ====================================================
# ====================== Options =====================
# ====================================================

case "$1" in
	-h)
		log_handler "Showing help (-h)."
		menu_header "${C}Help${N}"
		echo ""
		echo $(echo $(get_file_value $MODPATH/module.prop "description=") | sed 's|, |,\\n|g' | sed 's|\. |\.\\n|g')
		echo ""
		echo "Usage: props [options]..."
		echo ""
		echo "Options:"
		echo "  -f		Update fingerprints list."
		echo "  -l		Save module logs and info."
		echo "  -h		Show this message."
		echo "  -nc		Run without colours."
		echo "  -nw		Run without fingerprint startup check."
		echo "  -p		Improved hiding (edit prop files)."
		echo "  -r		Reset all options/settings."
		echo "  -s		Open script settings menu."
		echo ""
		echo "See the module readme or the"
		echo "support thread @ XDA for details."
		echo ""
		log_handler "Exiting... Bye bye.\n\n===================="
		exit 0
	;;	
esac

case "$1" in
	*d*) # Download developers prints list, for testing prints
		download_prints "Dev"
	;;
	*f*) # Update fingerprints list
		download_prints
	;;
	*l*) # Save logs
		menu_logs "Collect logs" "l"
	;;
	*p*) # Edit prop files
		menu_edit_prop_files "Edit prop files" "p"
	;;
	*r*) # Reset all settings
		reset_everything "Reset all settings" "r"
	;;
	*s*) # Open settings menu
		menu_options "Script settings" "s"
	;;
esac

if [ "$(get_file_value $LATEFILE "OPTIONWEB=")" == 0 ]; then
	WEBCHK="nw"
else
	WEBCHK="$1"
fi
case "$WEBCHK" in
	*nw*) # Do nothing
	;;
	*)	download_prints
	;;
esac

if [ "$1" ]; then
	case "$1" in
		*d*|*f*|*l*|*h*|*nc*|*nw*|*p*|*r*|*s*|*t*) # Do nothing
		;;
		*)
			log_handler "Invalid option."
			menu_header "${C}Help${N}"
			echo ""
			echo "${R}Invalid option.${N}"
			echo ""
			echo "Try again without options,"
			echo "or use -h for help and details."
			echo ""
			log_handler "Exiting... Bye bye.\n\n===================="	
			exit 0
		;;
	esac
fi

# ===================================================
# ==================== Main menu ====================
# ===================================================

while true
do
	orig_check
	if [ "$ORIGLOAD" == 0 ]; then
		log_handler "Original values are not loaded in propsconf_late."
		reboot_fn "The original prop values are not loaded,\n possibly due to a full reset of the module.\n\n Please reboot your device to reset." "reset-script"
	else
		INPUT=""
		ACTIVE="${G} (active)${N}"
		DISABLED="${R} (disabled)${N}"
		PRINTTXT=""
		FILETXT=""
		PROPTXT=""
		CUSTTXT=""
		DELTXT=""
		if [ -z "$INPUT" ]; then
			if [ "$(get_file_value $LATEFILE "FINGERPRINTENB=")" == 0 ]; then
				PRINTTXT=$DISABLED
			elif [ "$(get_file_value $LATEFILE "PRINTEDIT=")" == 1 ]; then
				PRINTTXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "FILESAFE=")" == 1 ]; then
				FILETXT=$DISABLED
			elif [ "$(get_file_value $LATEFILE "BUILDEDIT=")" == 1 ] || [ "$(get_file_value $LATEFILE "DEFAULTEDIT=")" == 1 ]; then
				FILETXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "PROPEDIT=")" == 1 ]; then
				PROPTXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "CUSTOMEDIT=")" == 1 ]; then
				CUSTTXT=$ACTIVE
			fi
			if [ "$(get_file_value $LATEFILE "DELEDIT=")" == 1 ]; then
				DELTXT=$ACTIVE
			fi
			menu_header "Select an option below."
			echo ""
			echo "${G}1${N} - Edit device fingerprint${PRINTTXT}"
			echo "${G}2${N} - Improved hiding${FILETXT}"
			echo "${G}3${N} - Edit MagiskHide props${PROPTXT}"
			echo "${G}4${N} - Add/edit custom props${CUSTTXT}"
			echo "${G}5${N} - Delete prop values${DELTXT}"
			echo "${G}6${N} - Script settings"
			echo "${G}7${N} - Collect logs"
			echo "${G}r${N} - Reset all options/settings"
			echo "${G}b${N} - Reboot device"
			echo ""
			if [ "$(get_file_value $LATEFILE "REBOOTCHK=")" == 1 ]; then
				echo "${R}Some options/settings have been changed.${N}"
				echo "${R}Please reboot for them to take affect.${N}"
				echo ""
			fi
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter '${G}e${N}' to exit: "
			read -r INPUT
		fi
		case "$INPUT" in
			1)	menu_change_fingerprint "Edit fingerprint${PRINTTXT}" $CURRFINGERPRINT $ORIGFINGERPRINT $MODULEFINGERPRINT
			;;
			2)	menu_edit_prop_files "Improved hiding${FILETXT}"
			;;
			3)	menu_magiskhide_props "MagiskHide props${PROPTXT}"
			;;
			4)	menu_custom_props "Custom props${CUSTTXT}"
			;;
			5)	menu_delete_props "Delete props${DELTXT}"
			;;
			6)	menu_options "Script settings"
			;;
			7)	menu_logs "Collect logs"
			;;
			r|R)	reset_everything "Reset all options/settings"
			;;
			b|B)	reboot_fn "Reboot device" "reboot"
			;;
			e|E)	exit_fn
			;;
			*)	invalid_input 1 1
			;;
		esac
	fi
done
